@page "/game/{ServerId:int}/{GameId:guid}"
@using CodeTogether.Client.Integration
@using CodeTogether.Client.Integration.Execution
@using CodeTogether.Client.Components.Execution
@using Microsoft.AspNetCore.SignalR.Client
@using GaelJ.BlazorCodeMirror6
@using GaelJ.BlazorCodeMirror6.Models
@using Timer = System.Timers.Timer
@inject NavigationManager Navigation
@inject HttpClient Http

<div class="container-fluid row border">
    <div class="col">
        <div class="row" style="flex-direction: row-reverse">
            <button class="position-absolute w-auto" style="translate: -12px; z-index: 1">Settings</button>
            <CodeMirror6Wrapper IsWASM
                                @bind-Doc="@Code"
                                Placeholder="Enter your code..."
                                TabSize="4"
                                IndentationUnit="4"
                                Theme="@ThemeMirrorTheme.VSCode"
                                Language="CodeMirrorLanguage.Csharp"
                                Setup="@setup"
                                Editable
                                ReadOnly="false"
                                LineWrapping="false"
                                MaxHeight="70vh" />
        </div>
        <div class="row">
            <button class="btn btn-primary btn-lg" @onclick="Submit">Submit</button>
            @if (submitting)
            {
                <div class="spinner-border m-5" role="status"></div>
            }
        </div>
        <div class="row">
            @if(submissionResult != null)
            {

            }
        </div>
    </div>

    <div class="col">
        <div class="row">
            Timer
        </div>
        <div class="row">
            @if (questionDto is not null)
            {
                <QuestionView Question="@questionDto" />
            }
            else
            {
                <p>Loading Question...</p>
            }
        </div>
    </div>

    <div class="col">
        @foreach (var codeContents in TheirCode.Values)
        {
            var maxHeight = $"calc(70vh / {TheirCode.Count})";
            <div class="row">
                <CodeMirror6Wrapper IsWASM
                                    @bind-Doc="@codeContents.Code"
                                    TabSize="4"
                                    Theme="@ThemeMirrorTheme.VSCode"
                                    Language="CodeMirrorLanguage.Csharp"
                                    ReadOnly="true"
                                    Editable="false"
                                    LineWrapping="true"
                                    MaxHeight="@maxHeight" />
            </div>
        }
    </div>
</div>

@code {

    [Parameter]
    public required Guid GameId { get; set; }

    [Parameter]
    public required int ServerId { get; set; }

    private Guid UserID { get; } = new(); // TODO: get user's actual GUID

    const double SendKeypressesDelayMs = 2000;

    private string code = string.Empty;
    private string Code
    {
        get => code;
        set
        {
            var lengthDifference = code.Length - value.Length;
            if (lengthDifference == 1)
            {
                for (var i = 0; i < value.Length; i++)
                {
                    if (code[i] == value[i]) continue;
                    unsentKeyPresses.Add(new KeyPressDTO { StateChange = "\b", StateChangePosition = i, IsEntireState = false });
                    code = value;
                    return;
                }
                unsentKeyPresses.Add(new KeyPressDTO { StateChange = "\b", StateChangePosition = code.Length, IsEntireState = false });
                code = value;
                return;
            }

            if (lengthDifference == -1)
            {
                for (var i = 0; i < code.Length; i++)
                {
                    if (code[i] == value[i]) continue;
                    unsentKeyPresses.Add(new KeyPressDTO { StateChange = value[i].ToString(), StateChangePosition = i, IsEntireState = false });
                    code = value;
                    return;
                }
                unsentKeyPresses.Add(new KeyPressDTO { StateChange = value[^1].ToString(), StateChangePosition = code.Length, IsEntireState = false });
                code = value;
                return;
            }

            unsentKeyPresses.Add(new KeyPressDTO { StateChange = value, IsEntireState = true });
            code = value;
        }
    }

    QuestionDTO? questionDto;

    private readonly CodeMirrorSetup setup = new()
    {
        BindMode = DocumentBindMode.OnInput,
        FocusOnCreation = true
    };

    private readonly List<KeyPressDTO> unsentKeyPresses = [];

    private Dictionary<Guid, SlowlyAppearingText> TheirCode { get; } = new();

    private HubConnection? hubConnection;

    private readonly Timer sendCodeTimer = new(SendKeypressesDelayMs);

    protected override async Task OnInitializedAsync()
    {
        hubConnection = new HubConnectionBuilder().WithUrl(Navigation.ToAbsoluteUri("/gamehub")).Build();

        hubConnection.On<Guid, List<KeyPressDTO>>("ReceiveKeyPresses", ReceiveKeyPresses);

        await hubConnection.StartAsync();

        sendCodeTimer.Elapsed += async (_, _) => await SendKeyPresses();
        sendCodeTimer.Enabled = true;

        await LoadNextQuestion();
    }

    async Task LoadNextQuestion()
    {
        var questionResponse = await Http.GetFromJsonAsync<QuestionDTO>($"api/question/get/{GameId}");
        if (questionResponse is not null)
        {
            LoadQuestion(questionResponse);
        }
    }

    void LoadQuestion(QuestionDTO question)
    {
        Code = question.ScaffoldCode;
        questionDto = question;
    }

    private async Task SendKeyPresses()
    {
        if (hubConnection is not null)
        {
            unsentKeyPresses.Add(new KeyPressDTO { StateChange = code, IsEntireState = true });
            await hubConnection.SendAsync("SendKeyPresses", UserID, unsentKeyPresses);
            unsentKeyPresses.Clear();
        }
    }

    bool submitting;
    ExecutionResponseDTO? submissionResult;
    async Task Submit()
    {
        if (questionDto == null)
        {
            return;
        }
        if (submitting)
        {
            return;
        }
        submitting = true;

        try
        {
            var request = new ExecutionRequestDTO
            {
                RawCode = Code,
                GameId = GameId,
                QuestionId = questionDto.Id
            };
            var response = await Http.PostAsJsonAsync<ExecutionRequestDTO>("api/execution/execute", request);
            response.EnsureSuccessStatusCode();
            submissionResult = await response.Content.ReadFromJsonAsync<ExecutionResponseDTO>();
        }
        finally
        {
            submitting = false;
        }
    }

    private void ReceiveKeyPresses(Guid userId, List<KeyPressDTO> keyPresses)
    {
        Console.WriteLine($"KeyPresses: [{string.Join(", ", keyPresses.Select(k => k.StateChange))}]");
        if (TheirCode.TryGetValue(userId, out var text))
        {
            text.SetKeyPresses(keyPresses);
        }
        else
        {
            TheirCode.Add(userId, new SlowlyAppearingText(keyPresses, this));
        }
    }

    private class SlowlyAppearingText
    {
        readonly Queue<KeyPressDTO> queue = [];
        readonly Timer doThingTimer;
        public string Code { get; set; } = string.Empty;

        public SlowlyAppearingText(List<KeyPressDTO> keyPresses, Game game)
        {
            keyPresses.ForEach(k => queue.Enqueue(k));
            doThingTimer = new Timer(SendKeypressesDelayMs / keyPresses.Count);
            doThingTimer.Elapsed += (_, _) =>
            {
                Console.WriteLine("doThingTimerElapsed");
                if (queue.Count == 0)
                {
                    doThingTimer.Enabled = false;
                    return;
                }
                var keyPress = queue.Dequeue();
                Console.WriteLine($"Key press: {keyPress.StateChange}");
                if (keyPress.IsEntireState)
                {
                    Code = keyPress.StateChange;
                }
                else if (keyPress.StateChange == "\b")
                {
                    Code = Code[..keyPress.StateChangePosition] + Code[(keyPress.StateChangePosition + 1)..];
                }
                else
                {
                    Code = Code[..keyPress.StateChangePosition] + keyPress.StateChange + Code[keyPress.StateChangePosition..];
                }
                game.InvokeAsync(game.StateHasChanged);
            };
            doThingTimer.Enabled = true;
        }

        public void SetKeyPresses(List<KeyPressDTO> keyPresses)
        {
            if (queue.Count != 0)
            {
                Code = queue.Last().StateChange;
                queue.Clear();
            }

            keyPresses.ForEach(k => queue.Enqueue(k));
            doThingTimer.Interval = SendKeypressesDelayMs / queue.Count;
            doThingTimer.Enabled = true;
        }
    }
}